<h1>
<a name="chapter1" class="anchor" href="#chapter1"><span class="octicon octicon-link"></span></a>Chapter 1 - Algorithms</h1>

<!--
TODO: Finding max element
TODO: Eratosphenus sieve
TODO: Finding gcd

Excercises:
TODO: Determining if a string is a palindrome
TODO: Finding all the perfect numbers less than given number (sum of all positive dividers is equal to number)
TODO: Program that solves a quadratic equation, input three coefficients, output the found roots
-->

<p>In this chapter we discuss what is an algorithm, time complexity, storage complexity and provide a few examples of algorithms.
</p>

<h2>What is an algorithm?</h2>

<p>
Let's first start with a discussion of what an algorithm is. Intuitively the definition is more or less clear, we are talking about some formal way to describe a computational procedure. According to the Merriam-Webster dictionary algorithm is "a set of steps that are followed in order to solve a mathematical problem or to complete a computer process".
</p>

<p>
Still this is probably not formal enough. How do we choose the next steps from the set of steps? Should we stop eventually? What is the result of an execution of an algorithm? There can be given many formal definitions of what constitutes an algorithm, however, at this point in the book, without introducing the abstract models of computation and what computation is, we will just give the following definition.
</p>

<div class="highlighted">
<div class="definition-term">Algorithm</div>
Set of computational steps which specifies a formal computational procedure and has the following properties:
<ol class="lower-alpha">
  <li>After each step is completed the next step is unambiguously defined or the algorithm stops its execution if there are no more steps left</li>
  <li>It is defined on a set of inputs and for each input it stops after a finite number of steps</li>
  <li>When it stops it produces a result which we call its output</li>
  <li>Its steps and their order of execution can be formally and unambiguously specified using some language or notation</li>
</ol>
</div>
<div class="artefact-label" href="#1.1">1.1 - Algorithm</div>

Algorithms can be expressed in a variety of ways. We can even specify the execution steps using the normal human language.
Let's provide a few simple examples. First trivial example will be multiplying two numbers.

<div class="highlighted no-artefact-label">
<div class="example-title">Algorithm of integer number multiplication.</div>
Steps:
<ol>
<li>Given two integer numbers multiply them and return the result</li>
</ol>
</div>

<p>
All the points from the definition of the algorithm are satisfied. There is only one step, after this step algorithm stops, the step is formally specified, all the integer numbers are valid inputs and a valid result will be produced for them. If we denote the algorithm for multiplication as <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>mult</mi></math> then, for example, <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math">
<mstyle>
  <mi>mult</mi>
    <mrow>
      <mo>(</mo>
      <mi>2</mi>
      <mo>,</mo>
      <mi>5</mi>
      <mo>)</mo>
    </mrow>
  <mo>=</mo>
  <mi>10</mi>
</mstyle>
</math> and we can formally specify the algorithm as follows <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math">
<mstyle>
  <mi>mult</mi>
    <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>)</mo>
    </mrow>
  <mo>=</mo>
  <mi>x</mi>
  <mo>*</mo>
  <mi>y</mi>
</mstyle>
</math>.
</p>

<p>
So far while talking about algorithms we encountered no JavaScript or any other programming language notation. This is quite intentional since we now clearly see that the notion of an algorithm is more of a mathematical one and it is quite abstract. Of course we can express any algorithm using JavaScript but this will be just one of the possible formal representations, in this case also executable by a JavaScript engine.
</p>

<p>
A careful reader might be a bit puzzled by our confidence at this point. How can we state that any algorithm can be expressed using JavaScript? Can this be in fact proven given the definition of an algorithm we gave earlier? Is JavaScript in fact powerful enough to express all the algorithms there can be? It turns out it is, but we will leave this statement without any proof until the very end of the book where we will discuss abstract models of computation and give even more formal and strict definition of an algorithm.
</p>

<p>
Let's look again at the definition 1.1 of algorithm and its part that states that we should be able to specify the computational procedure formally. Now it is more or less clear why we require this property from an algorithm. Then we can use a formal language such as JavaScript to specify the algorithm of our interest and execute this formal specification by using a machine such as a laptop or even smartphone. For the number multiplication algorithm this we can specify it like this:
</p>

<pre class="language-javascript">
<code>function mult(x, y) {
  return x * y;
}</code>
</pre>

<p>
We see that the specification using JavaScript is much more clear and shorter than using the natural language. Later in the book primarily JavaScript will be used, but we will keep in mind that the discussed algorithms can actually be expressed using other formal notations. Many Computer Science books go as far as inventing their own "pseudocode" in order to not be dependent on implementation details of a particular programming language. We will not go as far as they do and will happily use JavaScript, hence the name of the book "Algorithms with JavaScript".
</p>

<p>
Another question that we can ask by now are there any computational procedures that are not algorithms? Yes, there are and we will provide examples immediately.
</p>

<p>
First example is an infinite computational procedure which is by given definition not an algorithm:
</p>

<pre class="language-javascript">
<code>function getMaximumNumber() {
  var x = 0;
  while(true) {
    x++;
  }
  return x;
}</code>
</pre>

<p>
From this example we also see that not every computational procedure that can be formally expressed using some notation is an algorithm.
</p>

<p>
Another example of a non-algorithm will be the following division implementation defined on the set of all numbers:
</p>

<pre class="language-javascript">
<code>function divide(x, y) {
  if (y == 0) {
    throw new Error("Cannot divide by zero");
  }
  return x / y;
}</code>
</pre>

<p>
This is not an algorithm because the result is not defined for all the pairs <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math">
<mstyle>
  <mo>(</mo>
  <mi>x</mi>
  <mo>,</mo>
  <mi>y</mi>
  <mo>)</mo>
</mstyle>
</math> where <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>y</mi></math> is <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>0</mi></math>. However, it is easy to fix this and make the function <i>divide</i> specify an algorithm:
</p>

<pre class="language-javascript">
<code>function divide(x, y) {
  return y == 0 ? Infinity : x / y;
}</code>
</pre>

<p>
In fact in JavaScript returning <i>Infinity</i> when dividing by <i>0</i> is the default behavior so we can just write:
</p>

<pre class="language-javascript">
<code>function divide(x, y) {
  return x / y;
}</code>
</pre>

<p>
And this will be an algorithm, but only given the details of JavaScript engine implementation and the fact that it is possible to divide by <i>0</i> in JavaScript.
</p>

<p>
Now that we are finished with discussing the definition, let's try to take a look at a few more interesting algorithms.
</p>

<h2>Algorithm: finding maximum element</h2>

<p>
Let's try to find a maximum element in an array of elements. The algorithm is still quite simple:
</p>

<div class="highlighted">
<div class="example-title">Finding maximum element</div>
Given an array of or elements which can be empty:
<ol>
  <li>The current maximum is not defined in the beginning</li>
  <li>Take the next element in the array which was not yet taken, to be specific the next such element with the smallest index. If there is no next element (for example, the array is empty) go directly to the step 5.</li>
  <li>If the element is greater than the current maximum or the current maximum is not defined, update the current maximum to be the element</li>
  <li>Go to step 2</li>
  <li>Return maximum element</li>
</ol>
</div>
<div class="artefact-label" href="#1.2">1.2 - Finding maximum element</div>

<p>
The implementation in JavaScript:
</p>

<pre class="language-javascript line-numbers">
<code>function max(elements) {
    var max;

    for (var i = 0; i < elements.length; i++) {
      if (max == undefined || elements[i] > max) {
        max = elements[i];
      }
    }
    return max;
  }</code>
</pre>

<p>
This is in fact an algorithm: it is defined on all the arrays of numbers, finishes in a finite number of steps and can be formally specified. The code is more or less obvious, on the line 2 we declare the maximum and it is  <i>undefined</i> in the beginning. Then we go through all the elements of the array starting with the elements with smaller indexes in lines 4-8 and for each such element <i>elements[i]</i> we compare it to <i>max</i> and if the last is smaller than the current element or <i>undefined</i> we update <i>max</i> to be <i>elements[i]</i>. This corresponds to the algorithm specification given above in <i>1.2</i>.
</p>

<p>
In this case the algorithm is pretty straightforward and no other computational procedures can obviously be better. Also it is quite clear that we should look through all the elements in the array to find a maximum anyway. So, probably we cannot optimize this algorithm further.
</p>

<p>
However, usually the situation is not as clear as this one and we can have several algorithms that can be candidates for solving a particular problem and returning a result. In such a case we would like to choose the best algorithm. The best normally means the one that executes faster and requires less memory.
</p>

<p>
So far, we have not formalized what it means to be faster or more memory-efficient. Now is about time to rectify this and introduce formal means which will allow to compare algorithms to each other. First, let's start with the discussion of <i>time complexity</i>.
</p>

<h2>Time complexity</h2>

<p>
One of such important characteristics that can be used to compare algorithms with each other can be the time it takes to execute a program. In most cases we would like our algorithms to be fast, but what machine do we use to measure the time it takes the algorithm to finish its work on typical input? Should it be a smartphone, a tablet, or even a supercomputer?
</p>

<p>
Let's consider a more real-life metaphor for what we are trying to achieve here. Our situation is a bit like trying to reach point B from point A and having several routes to choose from. Here point A is the input for our algorithms, a route is an algorithm and point B is the output. The time it takes to reach point B corresponds to the execution time of an algorithm.
</p>

<p>
Should we measure the time it takes to drive a car from A to B for each of these roads? What if our car is accidentally loaded more when we drive on some of these roads? Do we then compare the different routes in a fair manner? What if the weather is different and due to the wind we drive slower? Or should we maybe use a bicycle altogether?
</p>

<p>
Clearly we would like to abstract away from all these accidental details related to how we reach point B from point A and compare the routes to each other using only the essential information we need. In this case such essential information can be the length of the route. If we take compare only the lengthes of the different routes we no longer care what road conditions there are, which car we use, and so forth. Of course, not only the length of the route matters, it may also matter whether the route is flat, how many curves it has or whether it goes through a road with no asphalt. But the route length is still a good first approximation.
</p>

<p>
Similarly in the case of algorithms comparing the execution time is also a good first approximation of how to compare algorithms. No doubt can be other characteristics that we would like to compare. One of such characterstics is the amount of memory an algorithm uses when it is executed, in fact, we will consider it just after the discussion of the time complexity. Other characteristics we would like to measure and compare to each other can be the number of assignment or read operations, etc.
</p>

<p>
So how do we go about execution time of the algorithm? How do we abstract it from a particular machine and execution on that machine similarly to our route from A to B metaphor?
</p>

<p>
One approach that we will follow is to count the number of primitive operations performed by an algorithm. By a primitive operation we mean comparing two numbers, remembering some value or referring to some value, etc. Alternatively we could measure the number of steps from the definition 1.1 of an algorithm but steps can be not equivalent in terms of time complexity: some steps can be relatively simple and other can include multiple operations.
</p>

<p>
So by now we agreed to measure the the number of primitive operations and approximate the resulting value as the execution time of algorithm. But what if the number of steps is different for different inputs?
</p>

<p>
For example, an algorithm that tries to find the first position of an element in an array can finish its work both after examining the first element in the input and the last. Here we will not be providing a formal specification of the algorithm in English but just provide the implementation in JavaScript right away. This is still a formal specification that we need according to the definition of an algorithm 1.1.
</p>

<pre class="language-javascript line-numbers with-artefact-label">
<code>function find(arr, element) {
  var position = -1;
  var currentIndex = 0;

  while ((position < 0) && (currentIndex < arr.length)) {
    if (arr[currentIndex] == element) {
      position = currentIndex;
    } else {
      currentIndex++;
    }
  }
  return position;
}</code>
</pre>
<div class="artefact-label" href="#1.3">1.3 - Finding element</div>

And a short example of invoking the <i>find</i> function:

<pre class="language-javascript">
<code>var arr = [1, 2, 3, 4, 5];

console.log(find(arr, 3)); //2
console.log(find(arr, 10)); //-1</code>
</pre>

<p>
How do we measure the number of primitive operations for such an algorithm given that it strongly depends on the provided array? The answer to this difficulty can be measuring the average number of primitive operations that can be observed by providing sufficiently large number of different arrays of the given length. In the first approximation and having no further specific information about the possible inputs we can assume that are random.
</p>

<p>
If you are familiar with the Probability Theory, speaking its language, we can define the time complexity as the mean of the number of primitive operations the algorithm performs given a particular distribution of the possible inputs for an algorithm.
</p>

<p>
Now if we try to give the estimation of the time complexity of the algorithm above, first we will count the number of primitive operations.
</p>

<p>
Lines 2, 3 and 12 give one primitive operation each, so this is <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>3</mi></math>, in lines 5 - 11 first we perform one comparison for all the elements except the last one for which we make an additional one, we will count this as <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>k</mi></math> primitive operations where <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>k</mi></math> is the number of steps before we find an element. It is obvious that <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math">
  <mi>0</mi>
  <mo>&le;</mo>
  <mi>k</mi>
  <mo>&le;</mo>
  <mi>n</mi>
</math>, where <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>n</mi></math> is the length of the array. On each iteration we additionally make one comparison in line 6 and one assignment in line 7 or line 9, this gives us <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math">
  <mi>3</mi>
  <mo>*</mo>
  <mi>k</mi>
</math> primitive operations for lines 5 - 11 in total. The formula for the time complexity for the case when there is such an element <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>k</mi></math> in the array will be:
</p>

<math xmlns='http://www.w3.org/1998/Math/MathML' class="math-expression">
  <mi>t</mi>
  <mrow>
    <mo>(</mo>
    <mi>k</mi>
    <mo>)</mo>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mi>3</mi>
    <mo>*</mo>
    <mi>k</mi>
    <mo>+</mo>
    <mi>3</mi>
  </mrow>
</math>

<p>
Taking the average by <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>k</mi></math> which is <math xmlns='http://www.w3.org/1998/Math/MathML' class="math-expression">
  <mfrac>
    <mi>n</mi>
    <mi>2</mi>
  </mfrac>
</math> we obtain the time complexity for the algorithm. In fact it can be represented as a function of the number of elements in the array <math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math"><mi>n</mi></math>:
</p>

<math xmlns='http://www.w3.org/1998/Math/MathML' class="math-expression">
  <mi>t</mi>
  <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mfrac>
      <mi>3</mi>
      <mi>2</mi>
    </mfrac>
    <mo>*</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mi>3</mi>
  </mrow>
</math>

<p>
Let's now look at the algorithm 1.2 for finding the maximum element. The number of primitive operations that this algorithm will perform also depends on the size of the input array, luckily for us, in this case, it does not depend on what the elements of the array are. In a similar fashion we find the time complexity of the algorithm to be:
</p>

<math xmlns='http://www.w3.org/1998/Math/MathML' class="math-expression">
  <mi>t</mi>
  <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mi>4</mi>
    <mo>*</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mi>1</mi>
  </mrow>
</math>

<p>
Now with these two examples we can finally give a formal definition of what the time complexity of an algorithm is. First, we can note that in these examples the time complexity was a function of the length of the input array. The length of the input array is here just a particular case of the size of an input. Let's define what the size of the input is formally.
</p>

<div class="highlighted">
<div class="definition-term">Input size</div>
Let's select a function that given an input produces a natural number or zero. The value produced by this function we will call the input size for a given input.
</div>
<div class="artefact-label" href="#1.4">1.4 - Input size</div>

<p>
In our two last examples the functon was length, however, according to the given definition there is considerable freedom in what to choose as the input size, for example, for an array it should not necessarily be the length, it can also be the minimum element or the number of odd elements, etc.
</p>

<div class="highlighted">
<div class="definition-term">Time complexity of algorithm</div>
<p>
Given an algorithm, a set of its possible inputs, and the distribution (relative frequencies) of those values, we define the time complexity of this algorithm as the average number of primitive operations (take value, assign value, compare two values, etc.) it takes the algorithm to complete its work.
</p>
<p>
The function that determines the input size for a given algorithm input is normally selected in such a manner that the time complexity of the algorithm for a given input can be determined only given the size of this input. In other words the time complexity can be expressed as a function of the input size.
</p>
</div>
<div class="artefact-label" href="#1.5">1.5 - Time complexity of algorithm</div>

<p>
In the examples above we found the time complexity of the algorithms for finding an element and finding a maximum element as the functions of the input size. This is normally what we will need to analyze how the time complexity of an algorithm changes given that its input size changes. Traditionally, we are normally interested in how the time complexity changes as the input size grows.
</p>

<p>
Given the definition 1.5 of the time complexity, clearly, if we want to compare the time complexity of two different algorithms then they should have the same set of inputs and input distribution. Otherwise we will be comparing apples to oranges or two functions of single argument with different arguments. As a rule this is not a problem as we normally would like to compare the efficiency and time complexity of algorithms that solve the same problem and therefore share the possible input values. An example of this we will see in this chapter a bit later when we compare two different algorithms for finding all the prime numbers less then a given number.
</p>

<h2>Big O-notation, Theta-notation</h2>

TODO:

Discuss that the O notation may in fact be irrelevant in case we are dealing with relatively small inputs like arrays of no more than 10 elements, etc.

<h2>Storage complexity</h2>

TODO:

Tradeoff speed vs. storage.

<h2>Eratosthenes sieve</h2>

TODO:

<h2>Euclidus algorithm</h2>

TODO:

<p>Here goes the contents and some JavaScript code</p>

<pre class="line-numbers language-javascript">
<code>function max(elements) {
  var max;

  for (var i = 0; i < elements.length; i++) {
    if (max == undefined || elements[i] > max) {
      max = elements[i];
    }
  }
  return max;
}</code>
</pre>

<p>
And here goes an illustration:
</p>

<!-- TODO: Use Handlebar template to render such thing as an illustration? -->

<div class="medium illustration">
  <img src="chapters/chapter1/svg/1.1.eratosthenes.sieve.svg" title="Sieve of Eratosthenes up to 15"/>
  <div class="artefact-label">1.1 - Sieve of Eratosthenes up to 15</div>
</div>

<p>
And after that we can use an inline formula

<math xmlns='http://www.w3.org/1998/Math/MathML' class="inline-math">
  <msup>
    <mi>e</mi>
    <mrow>
      <mn>2</mn>
      <mi>x</mi>
      <mo>+</mo>
      <mn>1</mn>
    </mrow>
  </msup>
</math>

</p>